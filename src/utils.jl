Base.show(io::IO, ::RandomSurface) = print(io, "RandomSurface")
Base.show(io::IO, ::FlatSurface) = print(io, "FlatSurface()")
Base.show(io::IO, s::GaussianSurface) = print(io, "GaussianSurface(d=$(s.d), a=$(s.a))")
Base.show(io::IO, s::SingleBumpSurface) = print(io, "SingleBumpSurface(d=$(s.d), a=$(s.a))")
Base.show(io::IO, s::RectangularSurface) = print(io, "RectangularSurface(d=$(s.d), km=$(s.km), kp=$(s.kp))")

Base.show(io::IO, ::Material) = print(io, "Material")
Base.show(io::IO, ::Vacuum) = print(io, "Vacuum")
Base.show(io::IO, m::Isotropic) = print(io, "Isotropic(ε=$(m.eps), μ=$(m.mu))")
Base.show(io::IO, m::Uniaxial) = print(io, "Uniaxial(εperp=$(m.eps_perp), εpara=$(m.eps_para), μperp=$(m.mu_perp), μpara=$(m.mu_para))")

"Parse string as generated by `Base.show`"
function Base.parse(::Type{RandomSurface}, str::String)::RandomSurface
    name, params = split(str, '(')
    params = split(strip(params, ")"), ',')
    return name == "RandomSurface" ? RandomSurface :
           name == "FlatSurface()" ? FlatSurface() :
           name == "GaussianSurface" ? GaussianSurface(parse.(Float64, params)...) :
           name == "SingleBumpSurface" ? GaussianSurface(parse.(Float64, params)...) :
           name == "RectangularSurface" ? GaussianSurface(parse.(Float64, params)...) :
           error("Unknown surface: $str")
end

function Base.parse(::Type{Material}, str::String)::Material
    name, params = split(str, '(')
    params = split(strip(params, ")"), ',')
    return name == "Material" ? Material :
           name == "Vacuum" ? Vacuum() :
           name == "Isotropic" ? Isotropic(parse.(ComplexF64, params)...) :
           name == "Uniaxial" ? Uniaxial(parse.(ComplexF64, params)...) :
           error("Unknown material: $str")
end

function Base.convert(::Type{Dict}, params::Parameters)::Dict
    return Dict(
        :lambda => params.lambda,
        :Lx => params.Lx,
        :Nx => params.Nx,
        :θs => params.θs,
        :Ni => params.Ni,
        :surf => params.surf,
        :above => params.above,
        :below => params.below,
        :seed => params.seed
    )
end

function Base.convert(::Type{Parameters}, dict::Dict)::Parameters
    return Parameters(
        lambda=dict[:lambda],
        Lx=dict[:Lx],
        Nx=dict[:Nx],
        θs=dict[:θs],
        Ni=dict[:Ni],
        surf=parse(RandomSurface, dict[:surf]),
        above=parse(Material, dict[:above]),
        below=parse(Material, dict[:below]),
        seed=dict[:seed],
        rescale=false
    )
end

function get_scaled_params(params::Parameters)::Dict
    k0 = 2π / params.lambda
    dict = convert(Dict, params)
    dict[:Lx] = params.Lx / k0
    dict[:surf] = scale(params.surf, 1 / k0)
    return dict
end

Base.show(params::Parameters) = println("Parameters($(["\n\t$(k)=$(v)" for (k, v) in get_scaled_params(params)]...)\n)")
Base.display(params::Parameters) = Base.show(params)

"""Load parameters from a file, dispatching based on file extension"""
function load_parameters(file::String)::Parameters
    # Ensure file has .json extension
    file = endswith(file, ".json") ? file : file * ".json"

    json_str = read(file, String)
    dict = Dict(JSON3.read(json_str))

    return convert(Parameters, dict)
end

function save_solver_data(file::String, out::SolverData)
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    jldopen(file, "a+") do io
        io["solverdata"] = out
    end
    return
end

function load_solver_data(file::String)::SolverData
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    return load(file, "solverdata")
end

# JSON save/load functions

"""Save Parameters to a JSON file"""
function save_parameters(file::String, params::Parameters; override::Dict=Dict())
    dict = params_to_dict(params)
    
    # Apply overrides
    for (k, v) in override
        dict[string(k)] = v
    end
    
    # Ensure file has .json extension
    file = endswith(file, ".json") ? file : file * ".json"
    
    open(file, "w") do io
        JSON3.pretty(io, dict) # Pretty print with 4-space indent
    end
    return
end