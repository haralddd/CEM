Base.show(io::IO, ::RandomSurface) = print(io, "RandomSurface")
Base.show(io::IO, ::FlatSurface) = print(io, "FlatSurface()")
Base.show(io::IO, s::GaussianSurface) = print(io, "GaussianSurface(d=$(s.d), a=$(s.a))")
Base.show(io::IO, s::SingleBumpSurface) = print(io, "SingleBumpSurface(d=$(s.d), a=$(s.a))")
Base.show(io::IO, s::RectangularSurface) = print(io, "RectangularSurface(d=$(s.d), km=$(s.km), kp=$(s.kp))")

Base.show(io::IO, ::PT) where {PT<:Polarization} = print(io, "$PT")
Base.show(io::IO, ::Material) = print(io, "Material")
Base.show(io::IO, ::Vacuum) = print(io, "Vacuum")
Base.show(io::IO, m::Isotropic) = print(io, "Isotropic(ε=$(m.eps), μ=$(m.mu))")
Base.show(io::IO, m::UniaxialCrystal) = print(io, "UniaxialCrystal(ε⟂=$(m.eps_perp), ε∥=$(m.eps_para), μ⟂=$(m.mu_perp)), μ∥=$(m.mu_para))")

Base.parse(::Type{Polarization}, str::String) = str == "PolarizationP" || str == "p" ? PolarizationP() :
                                                str == "PolarizationS" || str == "s" ? PolarizationS() :
                                                error("Unknown polarization: $str")

"Parse string as generated by `Base.show`"
function Base.parse(::Type{RandomSurface}, str::String)::RandomSurface
    name, params = split(str, '(')
    params = split(strip(params, ")"), ',')
    return name == "RandomSurface" ? RandomSurface :
           name == "FlatSurface()" ? FlatSurface() :
           name == "GaussianSurface" ? GaussianSurface(parse.(Float64, params)...) :
           name == "SingleBumpSurface" ? GaussianSurface(parse.(Float64, params)...) :
           name == "RectangularSurface" ? GaussianSurface(parse.(Float64, params)...) :
           error("Unknown surface: $str")
end

function Base.parse(::Type{Material}, str::String)::Material
    name, params = split(str, '(')
    params = split(strip(params, ")"), ',')
    return name == "Material" ? Material :
           name == "Vacuum" ? Vacuum() :
           name == "Isotropic" ? Isotropic(parse.(ComplexF64, params)...) :
           name == "UniaxialCrystal" ? UniaxialCrystal(parse.(ComplexF64, params)...) :
           error("Unknown material: $str")
end

function Base.convert(::Type{Dict}, spa::SimParams{_S, PT, _A, _B})::Dict where {_S, PT <: Polarization, _A, _B}
    return Dict(
        :polarization => PT(),
        :lambda => spa.lambda,
        :Q => spa.Q,
        :Nq => spa.Nq,
        :ks => spa.ks,
        :Lx => spa.Lx,
        :Ni => spa.Ni,
        :surf => spa.surf,
        :above => spa.above,
        :below => spa.below,
        :seed => spa.seed
    )
end

function Base.convert(::Type{SimParams}, dict::Dict)::SimParams
    surf = dict[:surf]
    @show pol = dict[:polarization]
    above = dict[:above]
    below = dict[:below]
    return SimParams{typeof(surf), typeof(pol), typeof(above), typeof(below)}(;
        lambda=dict[:lambda],
        Q=dict[:Q],
        Nq=dict[:Nq],
        ks=dict[:ks],
        Lx=dict[:Lx],
        Ni=dict[:Ni],
        surf=surf,
        above=above,
        below=below,
        seed=dict[:seed],
        rescale=false
    )
end

function get_scaled_params(spa::SimParams)::Dict
    s = spa.omega / c0
    dict = convert(Dict, spa)
    dict[:Lx] = spa.Lx / s
    dict[:surf] = scale(spa.surf, 1 / s)
    return dict
end

Base.show(spa::SimParams) = print("SimParams($(["\n\t$(k)=$(v)" for (k, v) in get_scaled_params(spa)]...)\n)")
Base.display(spa::SimParams) = Base.show(spa)

function save_spa_config(file::String, spa::SimParams; override::Dict=Dict())
    dict = convert(Dict, spa)
    for (k, v) in override
        dict[k] = v
    end
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    save(file, "config", dict)
end

function load_spa_config(file::String)::SimParams
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    return load(file)["config"]
end

function save_mdrc_data(file::String, coh, incoh)
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    save(file, "coh", coh, "incoh", incoh)
end

function load_mdrc_data(file::String)
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    return load(file)["coh"], load(file)["incoh"]
end

function save_ensemble_iters(file::String, iters)
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    save(file, "iters", iters)
end

function load_ensemble_iters(file::String)
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    return load(file)["iters"]
end

function interface_prompt()
    print("Interface type [flat|gaussian|singlebump|rect(West O'Donnell)] (=gaussian): ")
    input = readline()
    input = input == "" ? "gaussian" : input

    if input == "rect"
        print("West O'Donnell RMS height, δ [nm] (=5.0): ")
        input = readline()
        d = parse(Float64, input == "" ? "5.0" : input) * 1e-9

        print("West O'Donnell lower cutoff, k- [scaled to omega/c] (=0.8): ")
        input = readline()
        km = parse(Float64, input == "" ? "0.8" : input)

        print("West O'Donnell upper cutoff, k+ [scaled to omega/c] (=1.2): ")
        input = readline()
        kp = parse(Float64, input == "" ? "1.2" : input)

        return RectangularSurface(d, km, kp)
    elseif input == "gaussian"
        print("Gaussian RMS height, δ [nm] (=5.0): ")
        input = readline()
        d = parse(Float64, input == "" ? "5.0" : input) * 1e-9

        print("Gaussian correlation length, a [nm] (=1.0): ")
        input = readline()
        a = parse(Float64, input == "" ? "1.0" : input) * 1e-9

        return GaussianSurface(d, a)
    elseif input == "singlebump"
        print("Single bump RMS height, δ [nm] (=5.0): ")
        input = readline()
        d = parse(Float64, input == "" ? "5.0" : input) * 1e-9

        print("Single bump correlation length, a [nm] (=1.0): ")
        input = readline()
        a = parse(Float64, input == "" ? "1.0" : input) * 1e-9

        return SingleBumpSurface(d, a)
    else
        return FlatSurface()
    end
end

function material_prompt()
    print("Material type [vacuum|isotropic|uniaxialcrystal] (=vacuum): ")
    input = readline()
    input = input == "" ? "vacuum" : input
    if input == "uniaxialcrystal"
        print("Uniaxial crystal ε⟂ [complex] (=1.0): ")
        input = readline()
        eps_perp = parse(ComplexF64, input == "" ? "1.0" : input)

        print("Uniaxial crystal ε∥ [complex] (=1.0): ")
        input = readline()
        eps_para = parse(ComplexF64, input == "" ? "1.0" : input)

        print("Uniaxial crystal μ⟂ [complex] (=1.0): ")
        input = readline()
        mu_perp = parse(ComplexF64, input == "" ? "1.0" : input)

        print("Uniaxial crystal μ∥ [complex] (=1.0): ")
        input = readline()
        mu_para = parse(ComplexF64, input == "" ? "1.0" : input)

        return UniaxialCrystal(eps_perp, eps_para, mu_perp, mu_para)
    elseif input == "isotropic"
        print("Isotropic ε [complex] (=1.0): ")
        input = readline()
        eps = parse(ComplexF64, input == "" ? "1.0" : input)

        print("Isotropic μ [complex] (=1.0): ")
        input = readline()
        mu = parse(ComplexF64, input == "" ? "1.0" : input)

        return Isotropic(eps, mu)
    end

    return Vacuum()
end

function config_creation_prompt()::SimParams
    print("Input for solver parameters input SimParams struct\n")
    print("Polarization [p|s] (=p): ")
    input = readline()
    nu = parse(Polarization, input == "" ? "p" : input)

    print("lambda [nm] (=632.8): ")
    input = readline()
    lambda = parse(Float64, input == "" ? "632.8" : input) * 1e-9

    print("Q [multiple of omega/c] (=4): ")
    input = readline()
    Q = parse(Int64, input == "" ? "4" : input)

    print("Nq (=1024): ")
    input = readline()
    Nq = parse(Int64, input == "" ? "1024" : input)

    print("angles [list of deg \'0,1,2...\' OR range \'0:1:10\' OR \'fresnel\'] (=0:10:20): ")
    input = readline()
    if input == "fresnel"
        angles = 0.0:0.5:90.0
    elseif contains(input, ':') # Range input
        from, step, to = parse.(Float64, split(input == "" ? "0:10:20" : input, ':'))
        angles = from:step:to
    else
        angles = parse.(Float64, split(input == "" ? "0, 10, 20" : input, ','))
    end

    print("Lx [multiple of lambda] (=100): ")
    input = readline()
    Lx = parse(Float64, input == "" ? "100" : input) * lambda

    print("Ni (=10): ")
    input = readline()
    Ni = parse(Int64, input == "" ? "10" : input)

    surf = interface_prompt()

    println("Material above the interface (+)")
    above = material_prompt()
    println("Material below the interface (-)")
    below = material_prompt()

    print("Seed [Int64 >= 0] (= random seed): ")
    input = readline()
    seed = parse(Int64, input == "" ? "-1" : input)

    spa = SimParams{typeof(surf),typeof(nu),typeof(above),typeof(below)}(
        lambda=lambda,
        Q=Q,
        Nq=Nq,
        ks=sind.(angles),
        Lx=Lx,
        Ni=Ni,
        surf=surf,
        above=above,
        below=below,
        seed=seed,
        rescale=true,
    )

    print("Save config as input file? [y|n] (=n): ")
    input = readline()
    if input == "y"
        print("Filename [default.jld2]: ")
        input = readline()
        input = input == "" ? "default.jld2" : input
        save_spa_config("input/" * input, spa,
            override=Dict(:seed => seed) # Override the seed to generate random seed using the input
            )
    end

    return spa
end


"For debug purposes, mostly"
function default_config_creation()::Tuple{SimPrealloc, SimParams}
    spa = SimParams(
        lambda=632.8e-9,
        Q=4,
        Nq=1024,
        ks=[sind(10.0), sind(20.0), sind(30.0)],
        Lx=10.0e-6,
        Ni=10,
        surf=GaussianSurface(30.0e-9, 100.0e-9),
        rescale=true
    )

    sp = SimPrealloc(spa.Nq, length(spa.ks))

    return sp, spa
end

function default_params_for_surface_testing(surf::T)::Tuple{SimPrealloc, SimParams} where {T<:RandomSurface}
    spa = SimParams(
        lambda=632.8e-9,
        Q=4,
        Nq=1024,
        ks=[sind(10.0), sind(20.0), sind(30.0)],
        Lx=10.0e-6,
        Ni=10,
        surf=surf,
        rescale=true
    )

    sp = SimPrealloc(spa.Nq, length(spa.ks))

    return sp, spa

end


