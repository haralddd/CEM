Base.show(io::IO, ::RandomSurface) = print(io, "RandomSurface")
Base.show(io::IO, ::FlatSurface) = print(io, "FlatSurface()")
Base.show(io::IO, s::GaussianSurface) = print(io, "GaussianSurface(d=$(s.d), a=$(s.a))")
Base.show(io::IO, s::SingleBumpSurface) = print(io, "SingleBumpSurface(d=$(s.d), a=$(s.a))")
Base.show(io::IO, s::RectangularSurface) = print(io, "RectangularSurface(d=$(s.d), km=$(s.km), kp=$(s.kp))")
Base.show(rp::SimParams) = print("SimParams($(["\n\t$(k)=$(v)" for (k, v) in scaled_params(rp)]...)\n)")

Base.display(rp::SimParams) = Base.show(rp)


Base.parse(::Type{Polarization}, str::String) = str == "p" ? p :
                                                str == "s" ? s :
                                                error("Unknown polarization: $str")
"Parse string as generated by `Base.show`"
function Base.parse(::Type{RandomSurface}, str::String)::RandomSurface
    name, params = split(str, '(')
    params = split(strip(params, ")"), ',')
    return name == "RandomSurface" ? RandomSurface :
           name == "FlatSurface()" ? FlatSurface() :
           name == "GaussianSurface" ? GaussianSurface(parse.(Float64, params)...) :
           name == "SingleBumpSurface" ? GaussianSurface(parse.(Float64, params)...) :
           name == "RectangularSurface" ? GaussianSurface(parse.(Float64, params)...) :
           error("Unknown surface: $str")
end

function Base.convert(::Type{Dict}, rp::SimParams)::Dict
    return Dict(
        :nu => rp.nu,
        :eps => rp.eps,
        :mu => rp.mu,
        :lambda => rp.lambda,
        :omega => rp.omega,
        :Q => rp.Q,
        :ks => rp.ks,
        :Nq => rp.Nq,
        :Lx => rp.Lx,
        :Ni => rp.Ni,
        :surf => rp.surf,
        :seed => rp.seed
    )
end

function Base.convert(::Type{SimParams}, d::Dict)::SimParams
    return SimParams(;
        nu=d[:nu],
        eps=d[:eps],
        mu=d[:mu],
        lambda=d[:lambda],
        Q=d[:Q],
        ks=d[:ks],
        Nq=d[:Nq],
        L=d[:Lx],
        Ni=d[:Ni],
        surf=d[:surf],
        seed=d[:seed],
        rescale=false
    )
end

function save_to(rp::SimParams, label::String)
    filename = join([label, ".jld2"])
    save(filename, "struct", convert(Dict, rp))
    # save(filename, "SimParamsDescription", rp)
end

function load_rp_desc(file_path::String)::SimParams
    return load(file_path)["struct"]
end

function load_rp_struct(file_path::String)::SimParams
    return convert(SimParams, load(file_path)["struct"])
end

function surface_prompt()
    print("Surface type [flat|gaussian|singlebump|rect(West O'Donnell)] (=gaussian): ")
    input = readline()
    input = input == "" ? "gaussian" : input

    if input == "rect"
        print("West O'Donnell RMS height, δ [nm] (=5.0): ")
        input = readline()
        d = parse(Float64, input == "" ? "5.0" : input) * 1e-9

        print("West O'Donnell lower cutoff, k- [scaled to omega/c] (=0.8): ")
        input = readline()
        km = parse(Float64, input == "" ? "0.8" : input)

        print("West O'Donnell upper cutoff, k+ [scaled to omega/c] (=1.2): ")
        input = readline()
        kp = parse(Float64, input == "" ? "1.2" : input)

        return RectangularSurface(d, km, kp)
    elseif input == "gaussian"
        print("Gaussian RMS height, δ [nm] (=5.0): ")
        input = readline()
        d = parse(Float64, input == "" ? "5.0" : input) * 1e-9

        print("Gaussian correlation length, a [nm] (=1.0): ")
        input = readline()
        a = parse(Float64, input == "" ? "1.0" : input) * 1e-9

        return GaussianSurface(d, a)
    elseif input == "singlebump"
        print("Single bump RMS height, δ [nm] (=5.0): ")
        input = readline()
        d = parse(Float64, input == "" ? "5.0" : input) * 1e-9

        print("Single bump correlation length, a [nm] (=1.0): ")
        input = readline()
        a = parse(Float64, input == "" ? "1.0" : input) * 1e-9

        return SingleBumpSurface(d, a)
    else
        return FlatSurface()
    end
end

function config_creation_prompt()::Tuple{SimPrealloc, SimParams}
    print("Input for solver parameters input SimParams struct\n")
    print("Polarization [p|s] (=p): ")
    input = readline()
    nu = parse(Polarization, input == "" ? "p" : input)

    print("eps [X+Yim] (=2.25): ")
    input = readline()
    eps = parse(ComplexF64, input == "" ? "2.25" : input)

    print("mu [X+Yim] (=1.0): ")
    input = readline()
    mu = parse(ComplexF64, input == "" ? "1.0" : input)

    print("lambda [nm] (=632.8): ")
    input = readline()
    lambda = parse(Float64, input == "" ? "632.8" : input) * 1e-9

    print("Q [multiple of omega/c] (=4): ")
    input = readline()
    Q = parse(Int64, input == "" ? "4" : input)

    print("angles [list of deg <0,1,2...> OR range <0:1:10> OR \"fresnel\"] (=0:10:20): ")
    input = readline()
    if input == "fresnel"
        angles = 0.0:0.5:90.0
    elseif contains(input, ':') # Range input
        from, step, to = parse.(Float64, split(input == "" ? "0:10:20" : input, ':'))
        angles = from:step:to
    else
        angles = parse.(Int64, split(input == "" ? "0, 10, 20" : input, ','))
    end

    print("Nq (=1024): ")
    input = readline()
    Nq = parse(Int64, input == "" ? "1024" : input)

    print("L [multiple of lambda] (=100): ")
    input = readline()
    L = parse(Float64, input == "" ? "100" : input) * lambda

    print("Ni (=10): ")
    input = readline()
    Ni = parse(Int64, input == "" ? "10" : input)

    surf = surface_prompt()

    rp = SimParams(
        nu=nu,
        eps=eps,
        mu=mu,
        lambda=lambda,
        Q=Q,
        Nq=Nq,
        ks=sind.(angles),
        L=L,
        Ni=Ni,
        surf=surf
    )

    print("Save config to file? [y|n] (=n): ")
    input = readline()
    if input == "y"
        print("Filename: ")
        input = readline()
        save_as(rp, joinpath(["input", input]))
    end

    sp = SimPrealloc(Nq, length(angles))

    return sp, rp
end


"For debug purposes, mostly"
function default_config_creation()::Tuple{SimPrealloc, SimParams}
    rp = SimParams(
        lambda=632.8e-9,
        Q=4,
        Nq=1024,
        ks=[sind(10.0), sind(20.0), sind(30.0)],
        L=10.0e-6,
        Ni=10,
        surf=GaussianSurface(30.0e-9, 100.0e-9),
        rescale=true
    )

    sp = SimPrealloc(rp.Nq, length(rp.ks))

    return sp, rp
end

function default_params_for_surface_testing(surf::T)::Tuple{SimPrealloc, SimParams} where {T<:RandomSurface}
    rp = SimParams(
        lambda=632.8e-9,
        Q=4,
        Nq=1024,
        ks=[sind(10.0), sind(20.0), sind(30.0)],
        L=10.0e-6,
        Ni=10,
        surf=surf,
        rescale=true
    )

    sp = SimPrealloc(rp.Nq, length(rp.ks))

    return sp, rp

end


