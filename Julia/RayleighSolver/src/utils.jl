Base.show(io::IO, ::RandomSurface) = print(io, "RandomSurface")
Base.show(io::IO, ::FlatSurface) = print(io, "FlatSurface()")
Base.show(io::IO, s::GaussianSurface) = print(io, "GaussianSurface(d=$(s.d), a=$(s.a))")
Base.show(io::IO, s::SingleBumpSurface) = print(io, "SingleBumpSurface(d=$(s.d), a=$(s.a))")
Base.show(io::IO, s::RectangularSurface) = print(io, "RectangularSurface(d=$(s.d), km=$(s.km), kp=$(s.kp))")

Base.show(io::IO, ::PT) where {PT<:Polarization} = print(io, "$PT")
Base.show(io::IO, ::Material) = print(io, "Material")
Base.show(io::IO, ::Vacuum) = print(io, "Vacuum")
Base.show(io::IO, m::Isotropic) = print(io, "Isotropic(ε=$(m.eps), μ=$(m.mu))")
Base.show(io::IO, m::UniaxialCrystal) = print(io, "UniaxialCrystal(ε⟂=$(m.eps_perp), ε∥=$(m.eps_para), μ⟂=$(m.mu_perp)), μ∥=$(m.mu_para))")

Base.parse(::Type{Polarization}, str::String) = str == "PolarizationP" || str == "p" ? PolarizationP() :
                                                str == "PolarizationS" || str == "s" ? PolarizationS() :
                                                error("Unknown polarization: $str")

"Parse string as generated by `Base.show`"
function Base.parse(::Type{RandomSurface}, str::String)::RandomSurface
    name, params = split(str, '(')
    params = split(strip(params, ")"), ',')
    return name == "RandomSurface" ? RandomSurface :
           name == "FlatSurface()" ? FlatSurface() :
           name == "GaussianSurface" ? GaussianSurface(parse.(Float64, params)...) :
           name == "SingleBumpSurface" ? GaussianSurface(parse.(Float64, params)...) :
           name == "RectangularSurface" ? GaussianSurface(parse.(Float64, params)...) :
           error("Unknown surface: $str")
end

function Base.parse(::Type{Material}, str::String)::Material
    name, params = split(str, '(')
    params = split(strip(params, ")"), ',')
    return name == "Material" ? Material :
           name == "Vacuum" ? Vacuum() :
           name == "Isotropic" ? Isotropic(parse.(ComplexF64, params)...) :
           name == "UniaxialCrystal" ? UniaxialCrystal(parse.(ComplexF64, params)...) :
           error("Unknown material: $str")
end

function Base.convert(::Type{Dict}, spa::SimParams{_S, PT, _A, _B})::Dict where {_S, PT <: Polarization, _A, _B}
    return Dict(
        :polarization => PT(),
        :lambda => spa.lambda,
        :Q => spa.Q,
        :Nq => spa.Nq,
        :ks => spa.ks,
        :Lx => spa.Lx,
        :Ni => spa.Ni,
        :surf => spa.surf,
        :above => spa.above,
        :below => spa.below,
        :seed => spa.seed
    )
end

function Base.convert(::Type{SimParams}, dict::Dict)::SimParams
    surf = dict[:surf]
    @show pol = dict[:polarization]
    above = dict[:above]
    below = dict[:below]
    return SimParams{typeof(surf), typeof(pol), typeof(above), typeof(below)}(;
        lambda=dict[:lambda],
        Q=dict[:Q],
        Nq=dict[:Nq],
        ks=dict[:ks],
        Lx=dict[:Lx],
        Ni=dict[:Ni],
        surf=surf,
        above=above,
        below=below,
        seed=dict[:seed],
        rescale=false
    )
end

function get_scaled_params(spa::SimParams)::Dict
    s = spa.omega / c0
    dict = convert(Dict, spa)
    dict[:Lx] = spa.Lx / s
    dict[:surf] = scale(spa.surf, 1 / s)
    return dict
end

Base.show(spa::SimParams) = println("SimParams($(["\n\t$(k)=$(v)" for (k, v) in get_scaled_params(spa)]...)\n)")
Base.display(spa::SimParams) = Base.show(spa)

function save_spa_config(file::String, spa::SimParams; override::Dict=Dict())
    dict = convert(Dict, spa)
    for (k, v) in override
        dict[k] = v
    end

    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    jldopen(file, "a+") do io 
        io["spa"] = dict
    end
    return
end

function load_spa_config(file::String)::SimParams
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    return load(file, "spa")
end

function save_mdrc_data(file::String, out::SimOutput)
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    jldopen(file, "a+") do io
        io["out"] = out
    end
    return
end

function load_mdrc_data(file::String)::SimOutput
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    return load(file, "out")
end

function save_ensemble_iters(file::String, iters)
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    jldopen(file, "a+") do io
        io["iters"] = iters
    end
    return
end

function load_ensemble_iters(file::String)
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    return load(file, "iters")
end