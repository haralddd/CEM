Base.show(io::IO, ::RandomSurface) = print(io, "RandomSurface")
Base.show(io::IO, ::FlatSurface) = print(io, "FlatSurface()")
Base.show(io::IO, s::GaussianSurface) = print(io, "GaussianSurface(d=$(s.d), a=$(s.a))")
Base.show(io::IO, s::SingleBumpSurface) = print(io, "SingleBumpSurface(d=$(s.d), a=$(s.a))")
Base.show(io::IO, s::RectangularSurface) = print(io, "RectangularSurface(d=$(s.d), km=$(s.km), kp=$(s.kp))")

Base.show(io::IO, ::Material) = print(io, "Material")
Base.show(io::IO, ::Vacuum) = print(io, "Vacuum")
Base.show(io::IO, m::Isotropic) = print(io, "Isotropic(ε=$(m.eps), μ=$(m.mu))")
Base.show(io::IO, m::UniaxialCrystal) = print(io, "UniaxialCrystal(ε⟂=$(m.eps_perp), ε∥=$(m.eps_para), μ⟂=$(m.mu_perp)), μ∥=$(m.mu_para))")

"Parse string as generated by `Base.show`"
function Base.parse(::Type{RandomSurface}, str::String)::RandomSurface
    name, params = split(str, '(')
    params = split(strip(params, ")"), ',')
    return name == "RandomSurface" ? RandomSurface :
           name == "FlatSurface()" ? FlatSurface() :
           name == "GaussianSurface" ? GaussianSurface(parse.(Float64, params)...) :
           name == "SingleBumpSurface" ? GaussianSurface(parse.(Float64, params)...) :
           name == "RectangularSurface" ? GaussianSurface(parse.(Float64, params)...) :
           error("Unknown surface: $str")
end

function Base.parse(::Type{Material}, str::String)::Material
    name, params = split(str, '(')
    params = split(strip(params, ")"), ',')
    return name == "Material" ? Material :
           name == "Vacuum" ? Vacuum() :
           name == "Isotropic" ? Isotropic(parse.(ComplexF64, params)...) :
           name == "UniaxialCrystal" ? UniaxialCrystal(parse.(ComplexF64, params)...) :
           error("Unknown material: $str")
end

function Base.convert(::Type{Dict}, params::Parameters)::Dict
    return Dict(
        :lambda => params.lambda,
        :Lx => params.Lx,
        :Nx => params.Nx,
        :θs => params.θs,
        :Ni => params.Ni,
        :surf => params.surf,
        :above => params.above,
        :below => params.below,
        :seed => params.seed
    )
end

function Base.convert(::Type{Parameters}, dict::Dict)::Parameters
    return Parameters(
        lambda=dict[:lambda],
        Lx=dict[:Lx],
        Nx=dict[:Nx],
        θs=dict[:θs],
        Ni=dict[:Ni],
        surf=dict[:surf],
        above=dict[:above],
        below=dict[:below],
        seed=dict[:seed],
        rescale=false
    )
end

function get_scaled_params(params::Parameters)::Dict
    k0 = 2π / params.lambda
    dict = convert(Dict, params)
    dict[:Lx] = params.Lx / k0
    dict[:surf] = scale(params.surf, 1 / k0)
    return dict
end

Base.show(params::Parameters) = println("Parameters($(["\n\t$(k)=$(v)" for (k, v) in get_scaled_params(params)]...)\n)")
Base.display(params::Parameters) = Base.show(params)

# Base.show(data::SolverData) = println("SolverData($(["\n\t$(k)=$(v)" for (k, v) in data]...)\n)")
# Base.display(data::SolverData) = Base.show(data)

function save_spa_config(file::String, params::Parameters; override::Dict=Dict())
    dict = convert(Dict, params)
    for (k, v) in override
        dict[k] = v
    end

    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    jldopen(file, "a+") do io 
        io["params"] = dict
    end
    return
end

function load_spa_config(file::String)::Parameters
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    return load(file, "params")
end

function save_solver_data(file::String, out::SolverData)
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    jldopen(file, "a+") do io
        io["solverdata"] = out
    end
    return
end

function load_solver_data(file::String)::SolverData
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    return load(file, "solverdata")
end

function save_ensemble_iters(file::String, iters)
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    jldopen(file, "a+") do io
        io["iters"] = iters
    end
    return
end

function load_ensemble_iters(file::String)
    file = split(file, '.')[end] != "jld2" ? file*".jld2" : file
    return load(file, "iters")
end